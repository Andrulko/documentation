<html>
    
<style>
@font-face {
  font-family: octicons-link;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

.markdown-body {
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  line-height: 1.5;
  color: #24292e;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  font-size: 16px;
  line-height: 1.5;
  word-wrap: break-word;
  max-width: 1280px;
  margin: 20px auto;
}

.markdown-body .pl-c {
  color: #6a737d;
}

.markdown-body .pl-c1,
.markdown-body .pl-s .pl-v {
  color: #005cc5;
}

.markdown-body .pl-e,
.markdown-body .pl-en {
  color: #6f42c1;
}

.markdown-body .pl-smi,
.markdown-body .pl-s .pl-s1 {
  color: #24292e;
}

.markdown-body .pl-ent {
  color: #22863a;
}

.markdown-body .pl-k {
  color: #d73a49;
}

.markdown-body .pl-s,
.markdown-body .pl-pds,
.markdown-body .pl-s .pl-pse .pl-s1,
.markdown-body .pl-sr,
.markdown-body .pl-sr .pl-cce,
.markdown-body .pl-sr .pl-sre,
.markdown-body .pl-sr .pl-sra {
  color: #032f62;
}

.markdown-body .pl-v,
.markdown-body .pl-smw {
  color: #e36209;
}

.markdown-body .pl-bu {
  color: #b31d28;
}

.markdown-body .pl-ii {
  color: #fafbfc;
  background-color: #b31d28;
}

.markdown-body .pl-c2 {
  color: #fafbfc;
  background-color: #d73a49;
}

.markdown-body .pl-c2::before {
  content: "^M";
}

.markdown-body .pl-sr .pl-cce {
  font-weight: bold;
  color: #22863a;
}

.markdown-body .pl-ml {
  color: #735c0f;
}

.markdown-body .pl-mh,
.markdown-body .pl-mh .pl-en,
.markdown-body .pl-ms {
  font-weight: bold;
  color: #005cc5;
}

.markdown-body .pl-mi {
  font-style: italic;
  color: #24292e;
}

.markdown-body .pl-mb {
  font-weight: bold;
  color: #24292e;
}

.markdown-body .pl-md {
  color: #b31d28;
  background-color: #ffeef0;
}

.markdown-body .pl-mi1 {
  color: #22863a;
  background-color: #f0fff4;
}

.markdown-body .pl-mc {
  color: #e36209;
  background-color: #ffebda;
}

.markdown-body .pl-mi2 {
  color: #f6f8fa;
  background-color: #005cc5;
}

.markdown-body .pl-mdr {
  font-weight: bold;
  color: #6f42c1;
}

.markdown-body .pl-ba {
  color: #586069;
}

.markdown-body .pl-sg {
  color: #959da5;
}

.markdown-body .pl-corl {
  text-decoration: underline;
  color: #032f62;
}

.markdown-body .octicon {
  display: inline-block;
  vertical-align: text-top;
  fill: currentColor;
}

.markdown-body a {
  background-color: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline-width: 0;
}

.markdown-body strong {
  font-weight: inherit;
}

.markdown-body strong {
  font-weight: bolder;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border-style: none;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body hr {
  box-sizing: content-box;
  height: 0;
  overflow: visible;
}

.markdown-body input {
  font: inherit;
  margin: 0;
}

.markdown-body input {
  overflow: visible;
}

.markdown-body [type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body * {
  box-sizing: border-box;
}

.markdown-body input {
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}

.markdown-body a {
  color: #0366d6;
  text-decoration: none;
}

.markdown-body a:hover {
  text-decoration: underline;
}

.markdown-body strong {
  font-weight: 600;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #dfe2e5;
}

.markdown-body hr::before {
  display: table;
  content: "";
}

.markdown-body hr::after {
  display: table;
  clear: both;
  content: "";
}

.markdown-body table {
  border-spacing: 0;
  border-collapse: collapse;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body h1 {
  font-size: 32px;
  font-weight: 600;
}

.markdown-body h2 {
  font-size: 24px;
  font-weight: 600;
}

.markdown-body h3 {
  font-size: 20px;
  font-weight: 600;
}

.markdown-body h4 {
  font-size: 16px;
  font-weight: 600;
}

.markdown-body h5 {
  font-size: 14px;
  font-weight: 600;
}

.markdown-body h6 {
  font-size: 12px;
  font-weight: 600;
}

.markdown-body p {
  margin-top: 0;
  margin-bottom: 10px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code {
  font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
  font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body .octicon {
  vertical-align: text-bottom;
}

.markdown-body .pl-0 {
  padding-left: 0 !important;
}

.markdown-body .pl-1 {
  padding-left: 4px !important;
}

.markdown-body .pl-2 {
  padding-left: 8px !important;
}

.markdown-body .pl-3 {
  padding-left: 16px !important;
}

.markdown-body .pl-4 {
  padding-left: 24px !important;
}

.markdown-body .pl-5 {
  padding-left: 32px !important;
}

.markdown-body .pl-6 {
  padding-left: 40px !important;
}

.markdown-body::before {
  display: table;
  content: "";
}

.markdown-body::after {
  display: table;
  clear: both;
  content: "";
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body a:not([href]) {
  color: inherit;
  text-decoration: none;
}

.markdown-body .anchor {
  float: left;
  padding-right: 4px;
  margin-left: -20px;
  line-height: 1;
}

.markdown-body .anchor:focus {
  outline: none;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 0.25em;
  padding: 0;
  margin: 24px 0;
  background-color: #e1e4e8;
  border: 0;
}

.markdown-body blockquote {
  padding: 0 1em;
  color: #6a737d;
  border-left: 0.25em solid #dfe2e5;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #444d56;
  vertical-align: middle;
  background-color: #fafbfc;
  border: solid 1px #c6cbd1;
  border-bottom-color: #959da5;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #959da5;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 24px;
  margin-bottom: 16px;
  font-weight: 600;
  line-height: 1.25;
}

.markdown-body h1 .octicon-link,
.markdown-body h2 .octicon-link,
.markdown-body h3 .octicon-link,
.markdown-body h4 .octicon-link,
.markdown-body h5 .octicon-link,
.markdown-body h6 .octicon-link {
  color: #1b1f23;
  vertical-align: middle;
  visibility: hidden;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
  text-decoration: none;
}

.markdown-body h1:hover .anchor .octicon-link,
.markdown-body h2:hover .anchor .octicon-link,
.markdown-body h3:hover .anchor .octicon-link,
.markdown-body h4:hover .anchor .octicon-link,
.markdown-body h5:hover .anchor .octicon-link,
.markdown-body h6:hover .anchor .octicon-link {
  visibility: visible;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2em;
  border-bottom: 1px solid #eaecef;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.5em;
  border-bottom: 1px solid #eaecef;
}

.markdown-body h3 {
  font-size: 1.25em;
}

.markdown-body h4 {
  font-size: 1em;
}

.markdown-body h5 {
  font-size: 0.875em;
}

.markdown-body h6 {
  font-size: 0.85em;
  color: #6a737d;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li {
  word-wrap: break-all;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body li+li {
  margin-top: 0.25em;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: 600;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
}

.markdown-body table th {
  font-weight: 600;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #dfe2e5;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #c6cbd1;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f6f8fa;
}

.markdown-body img {
  max-width: 100%;
  box-sizing: content-box;
  background-color: #fff;
}

.markdown-body img[align=right] {
  padding-left: 20px;
}

.markdown-body img[align=left] {
  padding-right: 20px;
}

.markdown-body code {
  padding: 0.2em 0.4em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(27,31,35,0.05);
  border-radius: 3px;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .highlight {
  margin-bottom: 16px;
}

.markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body .highlight pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f6f8fa;
  border-radius: 3px;
}

.markdown-body pre code {
  display: inline;
  max-width: auto;
  padding: 0;
  margin: 0;
  overflow: visible;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body .full-commit .btn-outline:not(:disabled):hover {
  color: #005cc5;
  border-color: #005cc5;
}

.markdown-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
  line-height: 10px;
  color: #444d56;
  vertical-align: middle;
  background-color: #fafbfc;
  border: solid 1px #d1d5da;
  border-bottom-color: #c6cbd1;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #c6cbd1;
}

.markdown-body :checked+.radio-label {
  position: relative;
  z-index: 1;
  border-color: #0366d6;
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 0.2em 0.25em -1.6em;
  vertical-align: middle;
}

.markdown-body hr {
  border-bottom-color: #eee;
}
</style>
    
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>Python tutorial: fetching transactions</title></head><body class="markdown-body"><h1>Python tutorial: Fetching transactions</h1>

<p>In this tutorial we will show you how you can fetch existing transactions using IRI and the Python IOTA client library.</p>

<h2>How it works</h2>

<p>Every IOTA node (mainly IRI at this point) exposes several API endpoints that can be used to do various things. One of them is getting transactions to approve when you are sending a transaction (<code>getTips</code>), another is for sending a transaction/bundle to the tangle (<code>attachToTangle</code>) and others are there to fetch transaction data from the tangle like <code>getBalances</code>, <code>findTransactions</code> or <code>getTrytes</code>. Every client library made for IOTA will use these exposed API endpoints to interact with the Tangle through a node. An API reference can be found <a href="https://iota.readme.io/reference">here</a> describing all available methods and examples that show how to interact with them. </p>

<p>The IRI API is pretty low-level, you will need to do a lot yourself and know a lot about the IOTA protocol in-depth if you want to use it directly for sending and receiving transactions. To make it easier for a developer several client libraries are available to abstract the most common functionality for you making it easier to interact with the tangle through your programming language of choice. Currently we have client libraries available in Javascript (Typescript), C, C++, Java, Go and Python. We always recommend using one of our up-to-date and official libraries instead of interacting directly with IRI through the API in order to avoid mistakes and to make it easier on yourself to interact with the Tangle.</p>

<p>In this tutorial we will be using the <a href="https://github.com/iotaledger/iota.lib.py">iota.lib.py</a> library for Python, this will be very similar to how the other client libraries work. </p>

<h2>Prerequisites</h2>

<p>To replicate the examples below we need:</p>

<ul>
<li>An installation of Python (2.7/3.5/3.6)</li>
<li>PIP (Python package manager)</li>
<li>A virtual environment to run our application in (not required but highly recommended)</li>
<li>The iota.lib.py package (<code>pip install pyota</code>)</li>
</ul>

<p>You can run these examples in a Python script or a interactive Python shell session. </p>

<h2>Connecting to a node</h2>

<p>Before we can start using the client we need to import it and initialize it with a node address to connect to:</p>

<pre><code>from iota import Iota

api = Iota(&#39;https://nodes.iota.cafe:443&#39;)
</code></pre>

<p>If you want to be able to fetch transactions as well for a given seed you can provide that as well when initializing the library:</p>

<pre><code>api = Iota(&#39;https://nodes.iota.cafe:443&#39;, &#39;YOURSEEDHERE&#39;)
</code></pre>

<h2>Fetching the total balance using a seed</h2>

<p>In order to fetch transactions we first need to make a selection of what transactions we want to look for. A common use case would be to fetch transactions by providing a single address, or all addresses belonging to a certain seed. If you&#39;ve initialized your library with a seed you can simply run the get_inputs method to fetch all addresses with transactions belonging to your seed:</p>

<pre><code>addresses = api.get_inputs()
</code></pre>

<p>This will return the addresses it can find for the given seed with transactions and the total balance:</p>

<pre><code>{&#39;inputs&#39;: [Address(b&#39;IBTLTWJPCA9BKUIHAUDDKM9ZLKYBDJNTNJESCNBK9IBBQPDJKRXSPIQYHXNRMEBILGFPKXNUOFXMHHENX&#39;)],
 &#39;totalBalance&#39;: 1}
</code></pre>

<p>In this example the total balance is 1 iota and there&#39;s only 1 address used for this seed.</p>

<h2>Fetching balances using a list of addresses</h2>

<p>If you wish to fetch the confirmed balance for a single address or multiple addresses without having to provide the seed to your code you can do so as well:</p>

<pre><code>api.get_balances(addresses=[&#39;IBTLTWJPCA9BKUIHAUDDKM9ZLKYBDJNTNJESCNBK9IBBQPDJKRXSPIQYHXNRMEBILGFPKXNUOFXMHHENX&#39;])
</code></pre>

<p>This will return:</p>

<pre><code>{&#39;balances&#39;: [1],
 &#39;milestone&#39;: None,
 &#39;duration&#39;: 0,
 &#39;milestoneIndex&#39;: 915595,
 &#39;references&#39;: [&#39;ZKYQEHDDFWTTZUFTXWYYFZOPVNDMECNVXDBPNMDZAQQJLE9HAAQVZWWPEGSFSUWMMYBBCCIZDAKKA9999&#39;]}
</code></pre>

<p>If you just need an overview of confirmed balance for certain addresses this might be all you need for your use-case.</p>

<h2>Finding transactions</h2>

<p>To find the actual transaction hashes for a certain address, or a lost of addresses, use the <code>find_transaction</code> method:</p>

<pre><code>hashes = api.find_transactions(addresses=[&#39;IBTLTWJPCA9BKUIHAUDDKM9ZLKYBDJNTNJESCNBK9IBBQPDJKRXSPIQYHXNRMEBILGFPKXNUOFXMHHENX&#39;])  
</code></pre>

<p>This returns a dictionary with a list of hashes and the duration it took to process the request:</p>

<pre><code>{&#39;hashes&#39;: [TransactionHash(b&#39;IADZ9GCZY9CJJKGQMTQBPWJUYKOPPDVOGAFNAIOEJ9YA9TAJCZKQREECMFGXEUFUMZPEBFFGLEVWZ9999&#39;),
TransactionHash(b&#39;PLURFNVBVAOOZFOLDGGGBOONTJIES99YXSVYGGQ9WBAIOM9WFRSZXBRQWKZKRQAZTFVYQKLDSGQF99999&#39;),
TransactionHash(b&#39;THPIWTNWST9ALTNIMNHIGCIHAIZCRHNCARFRDIUHKRPASBNE9PC9MVWXXAINJFIREWZAFGFVENGPA9999&#39;),
TransactionHash(b&#39;D99NDB9FFWSNOEKNVNOWJPZIXVGCVKHNNJAVMMFSXXGALGANIUJJRKDNVTY9OXFXKQCUAFGOYMPWA9999&#39;)],
 &#39;duration&#39;: 0}
</code></pre>

<p>These hashes by itself are not very useful to us, but we can use them in the next step to fetch the bundle(s) associated with them for more details.</p>

<h2>Checking if transactions are confirmed</h2>

<p>The transaction hashes returned by the <code>find_transactions</code> method can be both confirmed or unconfirmed. If you need to be sure the transactions you are handling are confirmed you should check the inclusion state of your transactions. The inclusion state of the transaction tells you if the transaction is confirmed by a milestone. For financial transactions you should always check this.</p>

<pre><code>included = api.get_latest_inclusion(hashes[&#39;hashes&#39;])
</code></pre>

<p>This returns a dictionary with a single &#39;states&#39; key, this entry contains another dictionary with as the key the Transaction Hash and as the value either True or False (included or not). If we only want to have the TransactionHashes that are actually confirmed we can simply loop over them and checking if they have a <code>True</code> value:</p>

<pre><code>confirmed_hashes = []

for txhash, confirmed in included[&#39;states&#39;].items():
    if confirmed:  
        confirmed_hashes.append(txhash)
</code></pre>

<p>Our <code>confirmed_hashes</code> list now only contains the transactions hashes that are actually referenced by a milestone:</p>

<pre><code>[TransactionHash(b&#39;XMPMUTUONRQIDYBDQDZLMKIIWJTWYLATSNJOGHFIYJNPUOLNTZVWVFJBLUVR9TEGKHODBUZYDVFO99999&#39;),
 TransactionHash(b&#39;THPIWTNWST9ALTNIMNHIGCIHAIZCRHNCARFRDIUHKRPASBNE9PC9MVWXXAINJFIREWZAFGFVENGPA9999&#39;), 
 TransactionHash(b&#39;D99NDB9FFWSNOEKNVNOWJPZIXVGCVKHNNJAVMMFSXXGALGANIUJJRKDNVTY9OXFXKQCUAFGOYMPWA9999&#39;)]
</code></pre>

<h2>Fetching a bundle and transactions by a transaction hash</h2>

<p>To fetch the bundle(s) for a transaction hash we need to call the <code>get_bundles</code> method:</p>

<pre><code>bundles = api.get_bundles(&#39;IADZ9GCZY9CJJKGQMTQBPWJUYKOPPDVOGAFNAIOEJ9YA9TAJCZKQREECMFGXEUFUMZPEBFFGLEVWZ9999&#39;)
</code></pre>

<p>This returns a dictionary with a bundles key containing a list of Bundle objects, often times this will just be a single bundle. A bundle object has a <code>transactions</code> attribute, so we can loop over all transactions within our bundle for details:</p>

<pre><code>for bundle in bundles[&#39;bundles&#39;]:
    for transaction in bundle.transactions:
        print(transaction)
</code></pre>

<p>This will print something like this for every transaction within the bundle:</p>

<pre><code>Transaction(**{&#39;hash_&#39;: TransactionHash(b&#39;IADZ9GCZY9CJJKGQMTQBPWJUYKOPPDVOGAFNAIOEJ9YA9TAJCZKQREECMFGXEUFUMZPEBFFGLEVWZ9999&#39;),
             &#39;signature_message_fragment&#39;: Fragment(b&#39;CCTCGDHD9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999&#39;),
             &#39;address&#39;: Address(b&#39;IBTLTWJPCA9BKUIHAUDDKM9ZLKYBDJNTNJESCNBK9IBBQPDJKRXSPIQYHXNRMEBILGFPKXNUOFXMHHENX&#39;),
             &#39;value&#39;: 1,
             &#39;legacy_tag&#39;: Tag(b&#39;HRINITY99999999999999999999&#39;),
             &#39;timestamp&#39;: 1544107591,
             &#39;current_index&#39;: 0,
             &#39;last_index&#39;: 3,
             &#39;bundle_hash&#39;: BundleHash(b&#39;E9ZSGZYXBGWL99QUKBQKIPLKGVROU9CXXGHXVLOSTGZOWHDINJKFIYX9ECDWHBLDQ99AHTGUVUBQPRGZ9&#39;),
             &#39;trunk_transaction_hash&#39;: TransactionHash(b&#39;INZZO9QDEGUBLKLCKOYCVSSYZIMQZWZKJ9OIFZXSFCLIUAEKCVQXM9CYDEURECGOLOMREOAJDINHZ9999&#39;),
             &#39;branch_transaction_hash&#39;: TransactionHash(b&#39;OASP9EMDBEOFBARVYFVRTHK9XRIGYBHSVIBRITAFGOQRSNBKZAXRGPMRCAFCZVXJ9Z9PCZ9XMIYQ99999&#39;),
             &#39;tag&#39;: Tag(b&#39;TRINITY99999999999999999999&#39;),
             &#39;attachment_timestamp&#39;: 1544107600248,
             &#39;attachment_timestamp_lower_bound&#39;: 0,
             &#39;attachment_timestamp_upper_bound&#39;: 3812798742493,
             &#39;nonce&#39;: Nonce(b&#39;ESARJ9999999999999999999999&#39;)})
</code></pre>

<p>This transaction object contains all available data about a transaction including the value, address it refers to, a tag and a signature or message fragment. You can use this data as you please for your use-case.</p>

<p>Our bundle object also comes with a handy <code>get_messages</code> function that will extract all encoded messages within the bundle (for example the messages you enter when you send a transaction through Trinity).</p>

<pre><code>bundle.get_messages()
</code></pre>

<p>Returns:</p>

<pre><code>[&#39;Test&#39;]
</code></pre>

<h2>A shortcut to fetch all transactions for a given seed</h2>

<p>If you just want to fetch a complete history (as known by the node you are connected to) of all transfers connected to your seed there is a handy shortcut available in the form of the <code>get_transfers</code> function. This function will fetch all bundles for all addresses for the seed. Optionally you can ask the function to check for the inclusion state as well so you can check if the bundles are confirmed. After they are returned by the function:</p>

<pre><code>bundles = api.get_transfers(inclusion_states=True)
</code></pre>

<p>This function returns the same dictionary as the <code>get_bundles</code> function above containing all the bundles for all our addresses with transactions. Since we asked for the inclusion state as well you can easily check each bundle to see if it is confirmed:</p>

<pre><code>for bundle in bundles[&#39;bundles&#39;]:
    if bundle.is_confirmed:
        print(&#39;bundle %s is confirmed&#39; % bundle.hash)
        # You can add your code to process this confirmed bundle here!
</code></pre>

<p>It&#39;s tempting to use this method because it&#39;s quick and easy to implement but there is a big caveat; It can become incredibly slow if you have a lot of transactions or addresses with transactions for your seed. For faster processing it is highly recommended to keep a state of what you already processed before so you don&#39;t have to fetch every transaction every time you want to see if there&#39;s a change. A example of keeping state is storing your total confirmed balance and already processed transaction hashes in a database and only check a new transaction if it&#39;s not in the processed database yet. This can make a huge difference in execution time for your application.</p>

<h2>Full example: showing all confirmed value transactions for a seed, including messages</h2>

<pre><code>from iota import Iota

# Connect to our node with our seed
api = Iota(&#39;https://nodes.iota.cafe:443&#39;, &#39;YOURSEEDHERE&#39;)

# Get all addresses for our seed with actual transactions, including balance
inputs = api.get_inputs()
print(&#39;Total balance: %s iota&#39; % inputs[&#39;totalBalance&#39;])
addresses = inputs[&#39;inputs&#39;]

# Find all transaction for our addresses
transactions = api.find_transactions(addresses=addresses)
hashes = transactions[&#39;hashes&#39;]

# Check if our transactions have been confirmed by a milestone
checked_hashes = api.get_latest_inclusion(hashes)

for hash, included in checked_hashes[&#39;states&#39;].items():
    if not included:  
        # The transaction is not confirmed, let&#39;s skip this one!
        continue

    bundles = api.get_bundles(hash)

    for bundle in bundles[&#39;bundles&#39;]:
        for transaction in bundle.transactions:

            # Skip transactions without value or negative value
            if transaction.value &lt;= 0:
                continue

            # Skip transactions that are not referencing one of our addresses
            if not transaction.address in addresses:
                continue

            # All remaining transactions should be incoming value transactions

            message = transaction.signature_message_fragment.as_string()

            print(&#39;Received: %s iota with message: %s&#39; % (transaction.value, message))
</code></pre>

<p>If this seed has any confirmed incoming transactions you should see a output similar to this:</p>

<pre><code>Total balance: 7 iota
Received: 6 iota with message: Hello
Received: 1 iota with message: Test
</code></pre>
</body></html>
